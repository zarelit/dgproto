/**
 * David Costa <david.costa@ieee.org>, Giuliano Peraz <giuliano.peraz@gmail.com>
 */

/**
 * This file contains all the implementation of the header protocol.h in the include directory
 * of this project. It is thought for simplifying the creation of the messages of the protocol.
 * This file must use OpenSSL and return ever a string that has to be freed after use.
 */

#include "../include/protocol.h"
#include "../include/utils.h"
#include "../include/common.h"

uint8_t*
create_m1 (size_t* msg_len, aid_t id, BIGNUM* Na_bn)
{

	// The whole message
	msg_data m1;

	// The id
	msg_data myid;

	// Nonce generated by the client
	msg_data Na;

	// Signature of the nonce
	msg_data sigNa;

	// Encrypted part of M1: {Na,sign(Na)}
	msg_data signedNa; // That is, the plaintext of encryptedNa
	msg_data encryptedNa;

	// IV of the seal and the key
	msg_data iv;
	msg_data ek;
	size_t eklen;

	// Convert the nonce in a bytestring
	Na.data = malloc(BN_num_bytes(Na_bn));
	Na.data_len = BN_bn2bin(Na_bn, Na.data);
	if(!Na.data || Na.data_len != (NONCE_LEN/8)){
		fprintf(stderr,"Error handling Na\n");
		exit(EXIT_FAILURE);
	}

	// Sign Na with our private key
	sigNa.data = sign(CLIENT_KEY, Na.data, Na.data_len, &(sigNa.data_len));

	// Build Na || sig(Na), then cipher it
	signedNa.data = conc_msgs(&(signedNa.data_len), 2, Na, sigNa);
	encryptedNa.data = encrypt(SERVER_PUBKEY, signedNa.data, signedNa.data_len, &(encryptedNa.data_len),
						&(iv.data), &(iv.data_len), &(ek.data), &eklen);
	ek.data_len = eklen;

	// Add the id
	myid.data = &id;
	myid.data_len = sizeof(id);

	m1.data = conc_msgs(&(m1.data_len), 4, myid, iv, ek, encryptedNa);

	//dump("ID",myid.data,myid.data_len);
	//dump("IV",iv.data,iv.data_len);
	//dump("EK",ek.data,ek.data_len);
	//dump("whole envelope", encryptedNa.data, encryptedNa.data_len);

	// cleanup
	free(Na.data);
	free(sigNa.data);
	free(signedNa.data);
	free(encryptedNa.data);
	free(iv.data);
	free(ek.data);

	*msg_len = m1.data_len;
	return m1.data;
}

uint8_t*
create_m2 (size_t* msg_len, aid_t id, BIGNUM* Nb, BIGNUM* Na, uint8_t** iv)
{
    uint8_t *msg; // The message this function is able to build
    uint8_t *enc_part, *plain;
    uint8_t *env_iv, *env_key; // Envelope's key and Initialization vector
    size_t sig_len, enc_part_len, iv_len, plain_len, env_iv_len, env_key_len;
    msg_data enc_parts[3];
    msg_data msg_parts[5];

    // Input error checking
    if (msg_len == NULL || Nb == NULL || Na == NULL || iv == NULL)
    {
        fprintf(stderr, "%s: Invalid parameter passed\n", __func__);
        msg = NULL;
        *msg_len = 0;
        goto exit_create_m2;
    }

    // Create the encrypted part of the message by concatenating Na, Nb and the signature
	enc_parts[0].data = malloc(BN_num_bytes(Na));
    enc_parts[0].data_len = BN_bn2bin(Na, enc_parts[0].data);
	enc_parts[1].data = malloc(BN_num_bytes(Nb));
    enc_parts[1].data_len = BN_bn2bin(Nb, enc_parts[1].data);
    enc_parts[2].data = sign(SERVER_KEY, enc_parts[1].data, enc_parts[1].data_len, &sig_len);
    enc_parts[2].data_len = sig_len;
    plain = conc_msgs(&plain_len, 3, enc_parts[0], enc_parts[1], enc_parts[2]);
    if (plain == NULL)
    {
        fprintf(stderr, "Error concatenating parts to be encrypted\n");
        free(enc_parts[0].data);
        free(enc_parts[1].data);
        free(enc_parts[2].data);
        msg = NULL;
        *msg_len = 0;
        goto exit_create_m2;
    }

    // Start encryption of plain
    enc_part = encrypt(CLIENT_PUBKEY, plain, plain_len, &enc_part_len, &env_iv, &env_iv_len,
                                                                       &env_key, &env_key_len);
    if (enc_part == NULL)
    {
        fprintf(stderr, "%s: Error during encryption of M1\n", __func__);
        msg_len = 0;
        msg = NULL;
        goto cleanup_create_m2;
    }

    // Create the random Initialization Vector
    *iv = generate_random_aes_iv(&iv_len);
    if (*iv == NULL)
    {
        fprintf(stderr, "Error generating the IV\n");
        msg = NULL;
        *msg_len = 0;
        goto cleanup_create_m2;
    }

    // Create the whole message by concatenating the clear text part and the encrypted one
    msg_parts[0].data = &id;
    msg_parts[0].data_len = sizeof(id);
    msg_parts[1].data = *iv;
    msg_parts[1].data_len = iv_len;
    msg_parts[2].data = env_iv;
    msg_parts[2].data_len = env_iv_len;
    msg_parts[3].data = env_key;
    msg_parts[3].data_len = env_key_len;
    msg_parts[4].data = enc_part;
    msg_parts[4].data_len = enc_part_len;
    msg = conc_msgs(msg_len, 5, msg_parts[0], msg_parts[1], msg_parts[2], msg_parts[3], msg_parts[4]);
    if (msg == NULL)
    {
        fprintf(stderr, "%s: Error concatenating message's parts\n", __func__);
        msg = NULL;
        *msg_len = 0;
    }

cleanup_create_m2:
    free(plain);
    if (enc_part != NULL) free(enc_part);

    free(enc_parts[0].data);
    free(enc_parts[1].data);
    free(enc_parts[2].data);
    free(msg_parts[2].data);
    free(msg_parts[3].data);

exit_create_m2:
    return msg;
}

uint8_t*
create_m3 (size_t* msg_len, uint8_t* key, BIGNUM* Nb, uint8_t* iv)
{
    return create_m4(msg_len, key, Nb, iv);
}

uint8_t*
create_m4 (size_t* msg_len, uint8_t* key, BIGNUM* Na, uint8_t* iv)
{
    uint8_t *encr_msg, *Na_digest;
    uint8_t *Na_bin_val;
    size_t Na_len, enc_len;

    // Input error checking
    if (msg_len == NULL || key == NULL || Na == NULL || iv == NULL)
    {
        fprintf(stderr, "%s: Invalid parameter passed\n", __func__);
        encr_msg = NULL;
        *msg_len = 0;
        goto exit_create_m4;
    }

    // Create the message by hashing the Na and encrypt it by means of key key
    Na_bin_val = malloc(BN_num_bytes(Na));
    Na_len = BN_bn2bin(Na, Na_bin_val);
    Na_digest = do_sha256_digest(Na_bin_val, Na_len);
    if (Na_digest == NULL)
    {
        fprintf(stderr, "Error building the digest for Na\n");
        encr_msg = NULL;
        *msg_len = 0;
        free(Na_bin_val);
        goto exit_create_m4;
    }

    encr_msg = do_aes256_crypt(Na_digest, 32, key, iv, &enc_len);
    if (encr_msg == NULL)
    {
        fprintf(stderr, "Error crypting the message m4\n");
        *msg_len = 0;
    }
    else
    {
        *msg_len = enc_len;
    }
    free(Na_bin_val);
    free(Na_digest);

exit_create_m4:
    return encr_msg;
}

BIGNUM*
generate_random_nonce (void){
	BIGNUM* nonce = BN_new();
	int x;

	if(!nonce){
		fprintf(stderr,"Out of memory\n");
		exit(EXIT_FAILURE);
	}

	x=BN_rand(nonce, NONCE_LEN, 0, 0);
	if(!x){
		fprintf(stderr,"Cannot generate a random nonce\n");
		exit(EXIT_FAILURE);
	}

	return nonce;
}

uint8_t*
generate_key (BIGNUM *Na, BIGNUM *Nb)
{
    uint8_t *key, *tmp;
    size_t tmp_len;
    msg_data key_parts[3];      // Will store Na, Nb and the SALT

    // Input error checking
    if (Na == NULL || Nb == NULL)
    {
        key = NULL;
        fprintf(stderr, "%s: Invalid parameter passed\n", __func__);
        goto exit_generate_key;
    }

    // Create the "message" to be hashed by SHA256 algorithm
	key_parts[0].data = malloc(BN_num_bytes(Na));
    key_parts[0].data_len = BN_bn2bin(Na, key_parts[0].data);
	key_parts[1].data = malloc(BN_num_bytes(Nb));
    key_parts[1].data_len = BN_bn2bin(Nb, key_parts[1].data);
    key_parts[2].data = (uint8_t*) &SALT;
    key_parts[2].data_len = SALT_SIZE;
    tmp = conc_msgs(&tmp_len, 3, key_parts[0], key_parts[1], key_parts[2]);
    if (tmp == NULL)
    {
        fprintf(stderr, "Error concatenating parts of the key\n");
        key = NULL;
        goto exit_generate_key;
    }

    // Get the key component hash and make the key from it
    key = do_sha256_digest(tmp, tmp_len);
    free(tmp);
    free(key_parts[0].data);
    free(key_parts[1].data);
    if (key == NULL)
    {
        fprintf(stderr, "Error creating the key\n");
    }

exit_generate_key:
    return key;
}

int
verifymessage_m1 (uint8_t *msg, size_t msg_len, BIGNUM** Na)
{
    int ret_val = 0;
    BIGNUM *client_nonce;
    const size_t iv_len = EVP_CIPHER_iv_length(EVP_aes_256_cbc());
    const uint8_t msg1_parts_num = 4;
    const uint8_t dec_parts_num = 2;
    msg_data msg1_parts[msg1_parts_num]; // Plaintext and ciphertext of M1
    msg_data dec_parts[dec_parts_num];  // The nonce and the signature of the nonce
    uint8_t *dec_msg_part; // Decrypted part of the message
    size_t dec_len;        // Length of dec_msg_part

    // Input error checking
    if (msg == NULL || msg_len == 0 || Na == NULL)
    {
        ret_val = 0;
        fprintf(stderr, "%s: Invalid parameter passed\n", __func__);
        goto exit_verifymessage_m1;
    }

    // Extract the plaintext and the ciphertext parts of M1
    msg1_parts[0].data = NULL;                  // Will contain the id label of the client
    msg1_parts[0].data_len = sizeof(aid_t);
    msg1_parts[1].data = NULL;                  // Will contain the iv for the envelope
    msg1_parts[1].data_len = iv_len;
    msg1_parts[2].data = NULL;                  // Will contain the encrypted key of the envelope
    msg1_parts[2].data_len = EK_LEN;
    msg1_parts[3].data = NULL;                  // Will contain the encrypted part of M1
    msg1_parts[3].data_len = msg_len - EK_LEN - iv_len - sizeof(aid_t);
    if (extr_msgs(msg, msg1_parts_num, &msg1_parts[0], &msg1_parts[1], &msg1_parts[2], &msg1_parts[3]) == 0)
    {
        fprintf(stderr, "%s: Error during the extraction of m1 parts\n", __func__);
        ret_val = 0;
        goto exit_verifymessage_m1;
    }

    // Verify the id of the client is correct
    if (*(msg1_parts[0].data) != 'A')
    {
        ret_val = 0;
        fprintf(stderr, "%s: Client is unknown\n", __func__);
        goto exit_verifymessage_m1;
    }

    // Decrypt the crypted part of the message
    dec_msg_part = decrypt(SERVER_KEY, msg1_parts[3].data, msg1_parts[3].data_len, &dec_len,
                           msg1_parts[1].data, msg1_parts[2].data, msg1_parts[2].data_len);
    if (dec_msg_part == NULL)
    {
        fprintf(stderr, "%s: Error decrypting encrypted M1 part\n", __func__);
        ret_val = 0;
        goto exit_verifymessage_m1;
    }
    // Get the nonce client_nonce and its signature
    dec_parts[0].data = NULL;                   // Will contain Na
    dec_parts[0].data_len = NONCE_LEN/8;
    dec_parts[1].data = NULL;                   // Will contain Na's signature by the client
    dec_parts[1].data_len = dec_len - dec_parts[0].data_len;
    ret_val = extr_msgs(dec_msg_part, dec_parts_num, &dec_parts[0], &dec_parts[1]);
    if (ret_val == 0)
    {
        fprintf(stderr, "%s: Error during the extraction of decrypted parts\n", __func__);
        goto exit_verifymessage_m1;
    }

    // Verify the correcteness of the signature of Na

    client_nonce = BN_bin2bn(dec_parts[0].data, dec_parts[0].data_len, NULL);
    if (client_nonce == NULL)
    {
        fprintf(stderr, "%s: Error extracting client_nonce from raw bits\n", __func__);
        ret_val = 0;
        goto exit_verifymessage_m1;
    }
    if (verify(CLIENT_PUBKEY, client_nonce, dec_parts[1].data, dec_parts[1].data_len) == 0)
    {
        fprintf(stderr, "%s: Error during verifing nonce signature\n", __func__);
        ret_val = 0;
        goto exit_verifymessage_m1;
    }
    *Na = BN_dup(client_nonce);
    if (*Na == NULL)
    {
        ret_val = 0;
        fprintf(stderr, "Error copying client_nonce to Na\n");
    }
    else
    {
        ret_val = 1;
    }

exit_verifymessage_m1:
    // Cleanup if needed
    if (client_nonce != NULL) BN_clear_free(client_nonce);
    if (msg1_parts[0].data != NULL) free(msg1_parts[0].data);
    if (msg1_parts[1].data != NULL) free(msg1_parts[1].data);
    if (msg1_parts[2].data != NULL) free(msg1_parts[2].data);
    if (msg1_parts[3].data != NULL) free(msg1_parts[3].data);
    if (dec_parts[0].data != NULL) free(dec_parts[0].data);
    if (dec_parts[1].data != NULL) free(dec_parts[1].data);

    return ret_val;
}

int
verifymessage_m2 (uint8_t *msg, size_t msg_len, BIGNUM *Na, BIGNUM **Nb, uint8_t** iv)
{
	// Message is "B" | IV | IV_envelope2 | EK2 | envelope{ Na | Nb | sign(Nb) }
	// Define its components
	msg_data id;
	msg_data IV;
	msg_data IVenv2;
	msg_data EK2;
	msg_data outEnv; // Encrypted envelope
	msg_data inEnv; // Decrypted envelope
	msg_data envNa;
	msg_data envNb;
	msg_data envNbSig;

	// Auxiliary variables
	int ret;
	int status = 1; // Ok, set 0 on error
	BIGNUM* envNaBN = NULL;

	// Determine components length
	id.data_len = sizeof(aid_t);
	// TODO: hardcoded values>:(
	IV.data_len = 16;
	IVenv2.data_len = 16;
	EK2.data_len = EK_LEN;
	outEnv.data_len = msg_len - (id.data_len + IV.data_len + IVenv2.data_len + EK2.data_len);
	envNa.data_len = NONCE_LEN/8;
	envNb.data_len = NONCE_LEN/8;

	// Split message in its main components
	ret = extr_msgs(msg,5, &id, &IV, &IVenv2, &EK2, &outEnv);
	if (ret != 1) return 0;

	// Verify ID
	if(id.data[0] != 'B') status=0;

	// Assign the iv we'll use later
	*iv = IV.data;

	// Open envelope
	inEnv.data = decrypt(CLIENT_KEY, outEnv.data, outEnv.data_len, &(inEnv.data_len), IVenv2.data, EK2.data, EK2.data_len);
	if(inEnv.data == NULL) status=0;

	// Split the content of the envelope and check it
	envNbSig.data_len = inEnv.data_len - (envNa.data_len + envNb.data_len);
	ret = extr_msgs(inEnv.data, 3, &envNa, &envNb, &envNbSig);
	if( ret != 1) status = 0;

	// Verify that received nonce is actually our generate Nonce
	envNaBN = BN_bin2bn(envNa.data, envNa.data_len, NULL);
	if(BN_cmp(Na,envNaBN)!= 0) status=0;

	// Pack received Nb in a bignum and then verify the signature
	*Nb = BN_bin2bn(envNb.data, envNb.data_len, NULL);
	ret = verify(SERVER_PUBKEY, *Nb, envNbSig.data, envNbSig.data_len);
	if(!ret) status=0;

	if(status != 0) return 1;
	else return 0;
}

int
verifymessage_m3 (uint8_t* msg, size_t msg_len, BIGNUM* Nb, uint8_t* key, uint8_t* iv)
{
    uint8_t *srv_dig; // Server digest, the hash of Nb computed locally
    uint8_t *cli_dig; // The SHA256(Nb) sent by the client
    uint8_t *Nb_bin_val;
    uint8_t ret_val;
    size_t cli_dig_len, Nb_len;

    // Input error checking
    if (msg == NULL || msg_len == 0 || Nb == NULL || key == NULL)
    {
        ret_val = 0;
        fprintf(stderr, "%s: Invalid parameter passed\n", __func__);
        goto exit_verifymessage_m3;
    }

    // Decrypt the message by means of the key
    cli_dig = do_aes256_decrypt(msg, msg_len, key, iv, &cli_dig_len);
    if (cli_dig == NULL)
    {
        fprintf(stderr, "Error decrypting message m3\n");
        ret_val = 0;
        goto exit_verifymessage_m3;
    }

    // Compute the digest of server-generated Nb
    Nb_len = BN_num_bytes(Nb);
    Nb_bin_val = malloc(Nb_len);
    BN_bn2bin(Nb, Nb_bin_val);
    srv_dig = do_sha256_digest(Nb_bin_val, Nb_len);
    if (srv_dig == NULL)
    {
        fprintf(stderr, "Error during the hashing of the message m3\n");
        ret_val = 0;
        free(Nb_bin_val);
        free(cli_dig);
        goto exit_verifymessage_m3;
    }

    // Check if the digests are the same
    ret_val = (memcmp(srv_dig, cli_dig, 256/8) != 0)? 0 : 1;
    free(Nb_bin_val);
    free(srv_dig);
    free(cli_dig);

exit_verifymessage_m3:
    return ret_val;
}

int
verifymessage_m4 (uint8_t* msg, size_t msg_len, BIGNUM* Na, uint8_t* key, uint8_t* iv)
{
    return verifymessage_m3(msg, msg_len, Na, key, iv);
}
